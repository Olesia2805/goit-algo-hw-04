# Result

|Algorithm            | Small                | Middle               | Large                |
|-------------------- | :------------------: | :------------------: | :------------------: |
|Insertion sort       |              0.00061 |              0.00072 |              0.00104 |
|Merge sort           |              0.00008 |              0.00009 |              0.00012 |
|Sort                 |              0.00005 |              0.00006 |              0.00008 |
|Sorted               |              0.00004 |              0.00004 |              0.00006 |

# Summary

З прикріплених до проєкту картинок (photo) та вищенаведеної таблиці (results) можна зробити наступні висновки:

1. **Insertion sort:**

   - Часова складність: від O(n) до O(n^2) 

   - Час виконання: від 0.00061 до 0.00104

2. **Merge sort:**

   - Часова складність: O(nlog n)

   - Час виконання: від 0.00008 до 0.00012

Обидві нижченаведені операції мають майже однакову часову складність через використання тієї ж вбудованої функції sorted(). Однак, є різниця в тому, що в першому випадку ми створюємо копію масиву, що може займати додаткову пам'ять, тоді як у другому випадку ми сортуємо масив без додаткової пам'яті для копіювання.

3. **Sort:**

   - Часова складність: O(nlog n)

   - Час виконання: від 0.00005 до 0.00008

4. **Sorted:**

   - Часова складність: O(nlog n)

   - Час виконання: від 0.00004 до 0.00006

Дана перевірка алгоритмів допоможе вибрати оптимальний алгоритм сортування залежно від обсягу даних, з якими треба працювати. Наприклад, для великих масивів краще використати алгоритми з меншою часовою складністю, такі як 3. Merge sort, 2. Sort та 1. Sorted, оскільки вони забезпечують кращий час виконання порівняно з Insertion sort.

Водночас якщо є впевненість, що дані вже майже впорядковані, Insertion sort може бути швидшим через свою адаптивність до частково впорядкованих даних.

Вибір алгоритму сортування залежить від:

    - розміру
    - стану вхідних даних
    - стійкості алгоритму
    - додаткової пам'яті
    - вимог до продуктивності (часової та просторової складності)

Завдяки багаторічним дослідженням можна вибрати оптимальний алгоритм сортування для конкретної ситуації. Також, неодхідно враховувати можливість використання вбудованих функцій сортування або сторонніх бібліотек, які можуть оптимізувати роботу з даними.